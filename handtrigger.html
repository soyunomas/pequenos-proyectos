<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>HandTrigger Web</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
<style>
  body {
    margin: 0;
    overflow: hidden;
    background-color: #121212;
    color: white;
  }
  .video-container {
    position: relative;
    width: 100vw;
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  #webcam {
    position: absolute;
    width: 100%;
    height: 100%;
    object-fit: cover;
    transform: scaleX(-1);
  }
  #output_canvas {
    position: absolute;
    width: 100%;
    height: 100%;
    object-fit: cover;
    transform: scaleX(-1);
    pointer-events: none;
  }
  .ui-layer {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 10;
  }
  .btn-settings {
    position: absolute;
    top: 20px;
    left: 20px;
    font-size: 2rem;
    background: none;
    border: none;
    cursor: pointer;
    pointer-events: auto;
    transition: transform 0.2s;
  }
  .btn-settings:hover {
    transform: scale(1.1);
  }
  #urlWarningBanner {
    position: absolute;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 1050;
    pointer-events: auto;
    box-shadow: 0 4px 15px rgba(0,0,0,0.5);
  }
</style>
</head>
<body>

<div class="video-container">
  <video id="webcam" autoplay playsinline></video>
  <canvas id="output_canvas"></canvas>
  <div class="ui-layer">
    <button class="btn-settings" id="btnOpenSettings" aria-label="Abrir configuración">⚙️</button>
    <div id="urlWarningBanner" class="alert alert-warning" role="alert">
      <strong>¡Atención!</strong> Debes configurar una URL válida en los ajustes.
    </div>
  </div>
</div>

<div class="modal fade" id="settingsModal" tabindex="-1" aria-labelledby="settingsModalLabel" aria-hidden="true" data-bs-theme="dark">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="settingsModalLabel">Configuración de HandTrigger</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Cerrar"></button>
      </div>
      <div class="modal-body">
        <div class="mb-3">
          <label for="targetUrlInput" class="form-label">URL Objetivo (Webhook / API)</label>
          <input type="url" class="form-control" id="targetUrlInput" placeholder="http://192.168.1.X/" required>
        </div>
        <div class="mb-3">
          <label for="cooldownInput" class="form-label">Tiempo sin rebote (segundos)</label>
          <input type="number" class="form-control" id="cooldownInput" value="1.0" min="0.5" step="0.5" required>
          <div class="form-text">Tiempo que la app ignorará tu mano tras un disparo exitoso.</div>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
        <button type="button" class="btn btn-primary" id="btnSaveSettings">Guardar ajustes</button>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

<script>
  let targetUrl = '';
  let isOnCooldown = false;
  let currentHandColor = '#FF0000'; 
  let cooldownTimeMs = 1000; 

  const videoElement = document.getElementById('webcam');
  const canvasElement = document.getElementById('output_canvas');
  const canvasCtx = canvasElement.getContext('2d');
  const targetUrlInput = document.getElementById('targetUrlInput');
  const cooldownInput = document.getElementById('cooldownInput');
  const settingsModal = new bootstrap.Modal(document.getElementById('settingsModal'));
  const warningBanner = document.getElementById('urlWarningBanner');

  document.getElementById('btnOpenSettings').addEventListener('click', () => {
    targetUrlInput.value = targetUrl;
    cooldownInput.value = (cooldownTimeMs / 1000).toString(); 
    settingsModal.show();
  });

  document.getElementById('btnSaveSettings').addEventListener('click', () => {
    const inputUrl = targetUrlInput.value.trim();
    const inputCooldown = parseFloat(cooldownInput.value);

    let hasError = false;

    if (!inputUrl) {
      targetUrlInput.classList.add('is-invalid');
      hasError = true;
    }

    if (isNaN(inputCooldown) || inputCooldown < 0.1) {
      cooldownInput.classList.add('is-invalid');
      hasError = true;
    }

    if (!hasError) {
      targetUrl = inputUrl;
      cooldownTimeMs = inputCooldown * 1000; 
      warningBanner.style.display = 'none'; 
      settingsModal.hide();
    } else {
      warningBanner.style.display = 'block';
    }
  });

  document.getElementById('targetUrlInput').addEventListener('input', function() {
    this.classList.remove('is-invalid');
  });

  document.getElementById('cooldownInput').addEventListener('input', function() {
    this.classList.remove('is-invalid');
  });

  function getDistance(p1, p2) {
    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
  }

  function isPalmOpen(landmarks) {
    const wrist = landmarks[0];
    const isPointingUp = [4, 8, 12, 16, 20].every(tipIdx => landmarks[tipIdx].y < wrist.y);

    const checkFinger = (tipIdx, pipIdx, mcpIdx) => {
      const dTip = getDistance(wrist, landmarks[tipIdx]);
      const dPip = getDistance(wrist, landmarks[pipIdx]);
      const dMcp = getDistance(wrist, landmarks[mcpIdx]);
      return (dTip > dPip) && (dPip > dMcp);
    };

    const indexOpen = checkFinger(8, 6, 5);
    const middleOpen = checkFinger(12, 10, 9);
    const ringOpen = checkFinger(16, 14, 13);
    const pinkyOpen = checkFinger(20, 18, 17);

    const thumbExtended = getDistance(wrist, landmarks[4]) > getDistance(wrist, landmarks[3]);
    const thumbSpread = getDistance(landmarks[4], landmarks[17]) > getDistance(landmarks[2], landmarks[17]);
    const thumbOpen = thumbExtended && thumbSpread;

    return isPointingUp && indexOpen && middleOpen && ringOpen && pinkyOpen && thumbOpen;
  }

  function drawCustomHand(ctx, landmarks, color) {
    ctx.strokeStyle = color;
    ctx.lineWidth = 1.5; 
    HAND_CONNECTIONS.forEach(conn => {
      const p1 = landmarks[conn[0]];
      const p2 = landmarks[conn[1]];
      ctx.beginPath();
      ctx.moveTo(p1.x * canvasElement.width, p1.y * canvasElement.height);
      ctx.lineTo(p2.x * canvasElement.width, p2.y * canvasElement.height);
      ctx.stroke();
    });

    const fingerTips =[4, 8, 12, 16, 20];
    ctx.lineWidth = 2; 
    fingerTips.forEach(tipIdx => {
      const p = landmarks[tipIdx];
      ctx.beginPath();
      ctx.arc(p.x * canvasElement.width, p.y * canvasElement.height, 8, 0, 2 * Math.PI);
      ctx.stroke(); 
    });
  }

  async function triggerHttpCall() {
    if (!targetUrl) return;

    isOnCooldown = true;
    
    // Controlador para cancelar la petición si tarda demasiado (evita bloqueos)
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 2000); // 2 segundos máx para conectar

    try {
      // TRUCO: Añadimos un timestamp (?t=...) para obligar al servidor a ver una URL "nueva"
      // y evitar que el navegador use la caché (304). Así siempre saldrá log (200).
      const separator = targetUrl.includes('?') ? '&' : '?';
      const uniqueUrl = `${targetUrl}${separator}t=${Date.now()}`;

      const response = await fetch(uniqueUrl, {
        method: 'GET',
        mode: 'no-cors',
        cache: 'no-store', // Orden explícita de no usar caché
        signal: controller.signal
      });

      clearTimeout(timeoutId);

      // Si llegamos aquí, la red funcionó (aunque sea 404 o 200, no hubo error de conexión)
      if (response.type === 'opaque' || response.ok) {
        currentHandColor = '#00FF00'; 
      } else {
        currentHandColor = '#FF0000'; 
      }

    } catch (error) {
      if (error.name === 'AbortError') {
         console.warn("La petición tardó demasiado y fue cancelada para no bloquear la app.");
      } else {
         console.error("Error de red:", error);
      }
      currentHandColor = '#FF0000'; 
    } finally {
      // El bloque finally asegura que el cooldown SIEMPRE se resetee, pase lo que pase
      setTimeout(() => {
        currentHandColor = '#FF0000';
        isOnCooldown = false;
      }, cooldownTimeMs);
    }
  }

  function onResults(results) {
    if (canvasElement.width !== videoElement.videoWidth) {
      canvasElement.width = videoElement.videoWidth;
      canvasElement.height = videoElement.videoHeight;
    }

    canvasCtx.save();
    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

    if (results.multiHandLandmarks && results.multiHandedness) {
      for (let i = 0; i < results.multiHandLandmarks.length; i++) {
        const landmarks = results.multiHandLandmarks[i];
        const handedness = results.multiHandedness[i].label; 

        const isRightHand = handedness === 'Left';

        if (!isRightHand) continue;

        drawCustomHand(canvasCtx, landmarks, currentHandColor);

        if (!isOnCooldown) {
          if (isPalmOpen(landmarks)) {
            triggerHttpCall();
          }
        }
      }
    }
    canvasCtx.restore();
  }

  const hands = new Hands({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
  });

  hands.setOptions({
    maxNumHands: 2, 
    modelComplexity: 1,
    minDetectionConfidence: 0.7,
    minTrackingConfidence: 0.7
  });
  hands.onResults(onResults);

  const camera = new Camera(videoElement, {
    onFrame: async () => {
      await hands.send({image: videoElement});
    },
    width: 1280,
    height: 720
  });

  camera.start().catch(err => {
    alert("No se pudo acceder a la cámara. Asegúrate de dar los permisos necesarios.");
    console.error(err);
  });
</script>
</body>
</html>
