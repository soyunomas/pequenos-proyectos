<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>HandTrigger Web - Eternal Energy</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
<style>
  body {
    margin: 0;
    overflow: hidden;
    background-color: #121212;
    color: white;
  }
  .video-container {
    position: relative;
    width: 100vw;
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  #webcam {
    position: absolute;
    width: 100%;
    height: 100%;
    object-fit: cover;
    transform: scaleX(-1);
  }
  #output_canvas {
    position: absolute;
    width: 100%;
    height: 100%;
    object-fit: cover;
    transform: scaleX(-1);
    pointer-events: none;
  }
  .ui-layer {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 10;
  }
  .btn-settings {
    position: absolute;
    top: 20px;
    left: 20px;
    font-size: 2rem;
    background: none;
    border: none;
    cursor: pointer;
    pointer-events: auto;
    transition: transform 0.2s;
  }
  .btn-settings:hover {
    transform: scale(1.1);
  }
  #urlWarningBanner {
    position: absolute;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 1050;
    pointer-events: auto;
    box-shadow: 0 4px 15px rgba(0,0,0,0.5);
  }
</style>
</head>
<body>

<div class="video-container">
  <video id="webcam" autoplay playsinline></video>
  <canvas id="output_canvas"></canvas>
  <div class="ui-layer">
    <button class="btn-settings" id="btnOpenSettings" aria-label="Abrir configuración">⚙️</button>
    <div id="urlWarningBanner" class="alert alert-warning" role="alert">
      <strong>¡Atención!</strong> Debes configurar una URL válida en los ajustes.
    </div>
  </div>
</div>

<div class="modal fade" id="settingsModal" tabindex="-1" data-bs-theme="dark">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Configuración HandTrigger</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body">
        <div class="mb-3">
          <label for="targetUrlInput" class="form-label">URL Objetivo</label>
          <input type="url" class="form-control" id="targetUrlInput" placeholder="http://192.168.1.X/" required>
        </div>
        <div class="mb-3">
          <label for="cooldownInput" class="form-label">Tiempo sin rebote (segundos)</label>
          <input type="number" class="form-control" id="cooldownInput" value="1.0" min="0.5" step="0.5" required>
        </div>
        <div class="form-check form-switch">
          <input class="form-check-input" type="checkbox" id="showSkeletonCheck" checked>
          <label class="form-check-label" for="showSkeletonCheck">Mostrar esqueleto de la mano</label>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
        <button type="button" class="btn btn-primary" id="btnSaveSettings">Guardar ajustes</button>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

<script>
  let targetUrl = '';
  let isOnCooldown = false;
  let currentHandColor = '#FF0000'; 
  let cooldownTimeMs = 1000; 
  let showSkeleton = true;

  const particles = [];

  class Particle {
    constructor(x, y, type) {
      this.type = type; 
      this.life = 1.0;  
      
      if (type === 'fire') {
        // Dispersión amplia para cubrir toda la mano
        this.x = x + (Math.random() - 0.5) * 80; 
        this.y = y + (Math.random() - 0.5) * 80;
        
        // Movimiento caótico hacia arriba
        this.vx = (Math.random() - 0.5) * 4; 
        this.vy = -Math.random() * 5 - 1;
        this.decay = Math.random() * 0.05 + 0.02;
        this.size = Math.random() * 30 + 10;
        
        // Fuego Naranja/Rojo intenso
        this.r = 255;
        this.g = Math.floor(Math.random() * 160);
        this.b = 0;
      } else if (type === 'flash') {
        this.x = x;
        this.y = y;
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 25 + 10;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.decay = Math.random() * 0.08 + 0.02; 
        this.size = Math.random() * 50 + 20;
        // Luz pura
        this.r = 255;
        this.g = 255;
        this.b = 200;
      }
    }

    update() {
      this.x += this.vx;
      this.y += this.vy;
      this.life -= this.decay;
      if (this.type === 'fire') this.size *= 0.92;
    }

    draw(ctx) {
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(${this.r}, ${this.g}, ${this.b}, ${this.life})`;
      ctx.fill();
    }
  }

  function spawnFire(x, y) {
    // Generamos muchas partículas por frame para que se vea potente
    for (let i = 0; i < 10; i++) {
      particles.push(new Particle(x, y, 'fire'));
    }
  }

  function spawnFlash(x, y) {
    for (let i = 0; i < 100; i++) {
      particles.push(new Particle(x, y, 'flash'));
    }
  }

  function updateAndDrawParticles(ctx) {
    ctx.globalCompositeOperation = 'lighter'; 
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.update();
      p.draw(ctx);
      if (p.life <= 0) {
        particles.splice(i, 1);
      }
    }
    ctx.globalCompositeOperation = 'source-over';
  }

  const videoElement = document.getElementById('webcam');
  const canvasElement = document.getElementById('output_canvas');
  const canvasCtx = canvasElement.getContext('2d');
  const targetUrlInput = document.getElementById('targetUrlInput');
  const cooldownInput = document.getElementById('cooldownInput');
  const showSkeletonCheck = document.getElementById('showSkeletonCheck');
  const settingsModal = new bootstrap.Modal(document.getElementById('settingsModal'));
  const warningBanner = document.getElementById('urlWarningBanner');

  document.getElementById('btnOpenSettings').addEventListener('click', () => {
    targetUrlInput.value = targetUrl;
    cooldownInput.value = (cooldownTimeMs / 1000).toString(); 
    showSkeletonCheck.checked = showSkeleton;
    settingsModal.show();
  });

  document.getElementById('btnSaveSettings').addEventListener('click', () => {
    const inputUrl = targetUrlInput.value.trim();
    const inputCooldown = parseFloat(cooldownInput.value);
    
    let hasError = false;

    if (!inputUrl) { targetUrlInput.classList.add('is-invalid'); hasError = true; }
    if (isNaN(inputCooldown) || inputCooldown < 0.1) { cooldownInput.classList.add('is-invalid'); hasError = true; }

    if (!hasError) {
      targetUrl = inputUrl;
      cooldownTimeMs = inputCooldown * 1000; 
      showSkeleton = showSkeletonCheck.checked;
      warningBanner.style.display = 'none'; 
      settingsModal.hide();
    } else {
      warningBanner.style.display = 'block';
    }
  });

  ['targetUrlInput', 'cooldownInput'].forEach(id => {
    document.getElementById(id).addEventListener('input', function() { this.classList.remove('is-invalid'); });
  });

  function getDistance(p1, p2) {
    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
  }

  // Comprobación estricta SOLO para el disparo
  function isPalmOpenAndUp(landmarks) {
    const wrist = landmarks[0];
    
    // 1. Orientación: ¿Están todas las puntas por encima de la muñeca?
    const isPointingUp = [4, 8, 12, 16, 20].every(tipIdx => landmarks[tipIdx].y < wrist.y);
    if (!isPointingUp) return false;

    // 2. Extensión: ¿Están los dedos estirados (radial)?
    const checkFinger = (tipIdx, pipIdx, mcpIdx) => {
      const dTip = getDistance(wrist, landmarks[tipIdx]);
      const dPip = getDistance(wrist, landmarks[pipIdx]);
      const dMcp = getDistance(wrist, landmarks[mcpIdx]);
      return (dTip > dPip) && (dPip > dMcp);
    };

    return checkFinger(8, 6, 5) && 
           checkFinger(12, 10, 9) && 
           checkFinger(16, 14, 13) && 
           checkFinger(20, 18, 17) &&
           (getDistance(wrist, landmarks[4]) > getDistance(wrist, landmarks[3]) && 
            getDistance(landmarks[4], landmarks[17]) > getDistance(landmarks[2], landmarks[17]));
  }

  function drawCustomHand(ctx, landmarks, color) {
    ctx.strokeStyle = color;
    ctx.lineWidth = 1.5; 
    HAND_CONNECTIONS.forEach(conn => {
      const p1 = landmarks[conn[0]];
      const p2 = landmarks[conn[1]];
      ctx.beginPath();
      ctx.moveTo(p1.x * canvasElement.width, p1.y * canvasElement.height);
      ctx.lineTo(p2.x * canvasElement.width, p2.y * canvasElement.height);
      ctx.stroke();
    });

    const fingerTips =[4, 8, 12, 16, 20];
    ctx.lineWidth = 2; 
    fingerTips.forEach(tipIdx => {
      const p = landmarks[tipIdx];
      ctx.beginPath();
      ctx.arc(p.x * canvasElement.width, p.y * canvasElement.height, 8, 0, 2 * Math.PI);
      ctx.stroke(); 
    });
  }

  async function triggerHttpCall(x, y) {
    if (!targetUrl) return;

    isOnCooldown = true;
    spawnFlash(x, y);

    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 2000); 

    try {
      const separator = targetUrl.includes('?') ? '&' : '?';
      const uniqueUrl = `${targetUrl}${separator}t=${Date.now()}`;

      const response = await fetch(uniqueUrl, {
        method: 'GET',
        mode: 'no-cors',
        cache: 'no-store', 
        signal: controller.signal
      });

      clearTimeout(timeoutId);

      if (response.type === 'opaque' || response.ok) {
        currentHandColor = '#00FF00'; 
      } else {
        currentHandColor = '#FF0000'; 
      }

    } catch (error) {
      if (error.name !== 'AbortError') console.error("Error de red:", error);
      currentHandColor = '#FF0000'; 
    } finally {
      setTimeout(() => {
        currentHandColor = '#FF0000';
        isOnCooldown = false;
      }, cooldownTimeMs);
    }
  }

  function onResults(results) {
    if (canvasElement.width !== videoElement.videoWidth) {
      canvasElement.width = videoElement.videoWidth;
      canvasElement.height = videoElement.videoHeight;
    }

    canvasCtx.save();
    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

    updateAndDrawParticles(canvasCtx);

    if (results.multiHandLandmarks && results.multiHandedness) {
      for (let i = 0; i < results.multiHandLandmarks.length; i++) {
        const landmarks = results.multiHandLandmarks[i];
        const handedness = results.multiHandedness[i].label; 
        const isRightHand = handedness === 'Left';

        if (!isRightHand) continue;

        // Centro de la mano para emanar energía
        const centerX = (landmarks[0].x + landmarks[9].x) / 2 * canvasElement.width;
        const centerY = (landmarks[0].y + landmarks[9].y) / 2 * canvasElement.height;

        // PREMISA: SIEMPRE QUE SE DETECTE LA MANO -> ENERGÍA
        spawnFire(centerX, centerY);

        if (showSkeleton) {
          drawCustomHand(canvasCtx, landmarks, currentHandColor);
        }

        if (!isOnCooldown) {
          // Lógica de disparo estricta: Mano Abierta y Arriba
          if (isPalmOpenAndUp(landmarks)) {
            triggerHttpCall(centerX, centerY);
          }
        }
      }
    }
    canvasCtx.restore();
  }

  const hands = new Hands({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
  });

  hands.setOptions({
    maxNumHands: 2, 
    modelComplexity: 1,
    minDetectionConfidence: 0.6, // Bajado ligeramente para mejorar seguimiento rápido
    minTrackingConfidence: 0.6
  });
  hands.onResults(onResults);

  const camera = new Camera(videoElement, {
    onFrame: async () => {
      await hands.send({image: videoElement});
    },
    width: 1280,
    height: 720
  });

  camera.start().catch(err => console.error(err));
</script>
</body>
</html>
